: "Annotation classes for BIM workbench.

Provides text labels and leader lines for technical drawings and annotations.
- TextLabel: Text with positioning, rotation, and styling
- LeaderLine: Lines connecting text to features with arrowheads
"""

from typing import Optional, Tuple, List, Dict, Any, Literal
from dataclasses import dataclass, field
from uuid import uuid4
import math


@dataclass
class TextStyle:
    """Style configuration for text labels."""
    # Text properties
    height: float = 2.5  # mm
    color: str = "black"
    font: str = "Arial"
    font_weight: str = "normal"  # normal, bold
    font_style: str = "normal"  # normal, italic
    
    # Alignment
    horizontal_align: Literal["left", "center", "right"] = "left"
    vertical_align: Literal["top", "middle", "bottom"] = "bottom"
    
    # Background
    background_color: Optional[str] = None
    background_padding: float = 1.0  # mm
    border_color: Optional[str] = None
    border_width: float = 0.25  # mm
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert style to dictionary."""
        return {
            "height": self.height,
            "color": self.color,
            "font": self.font,
            "font_weight": self.font_weight,
            "font_style": self.font_style,
            "horizontal_align": self.horizontal_align,
            "vertical_align": self.vertical_align,
            "background_color": self.background_color,
            "background_padding": self.background_padding,
            "border_color": self.border_color,
            "border_width": self.border_width,
        }


class TextLabel:
    """
    Text label with positioning and styling.
    
    Supports multi-line text, rotation, and various alignment options.
    Can include a background rectangle and border.
    
    Usage:
        label = TextLabel(
            text="Room 101",
            position=(100.0, 200.0),
            rotation=0.0,
            style=TextStyle(height=3.5, horizontal_align="center")
        )
    """
    
    def __init__(
        self,
        text: str,
        position: Tuple[float, float],
        rotation: float = 0.0,
        style: Optional[TextStyle] = None,
        layer: str = "Annotations",
        id: Optional[str] = None
    ):
        self.id = id or str(uuid4())
        self.text = text
        self.position = position
        self.rotation = rotation  # degrees
        self.style = style or TextStyle()
        self.layer = layer
        self.visible = True
        self.locked = False
        
        # Calculate bounding box
        self._calculate_bounds()
    
    def _calculate_bounds(self):
        """Calculate text bounding box."""
        lines = self.text.split('\n')
        self.line_count = len(lines)
        self.max_line_length = max(len(line) for line in lines) if lines else 0
        
        # Estimate text dimensions (approximate character width = 0.6 * height)
        char_width = self.style.height * 0.6
        self.text_width = self.max_line_length * char_width
        self.text_height = self.line_count * self.style.height * 1.2  # 1.2 = line spacing
        
        # Calculate insertion point based on alignment
        x, y = self.position
        
        if self.style.horizontal_align == "left":
            self.insertion_x = x
        elif self.style.horizontal_align == "center":
            self.insertion_x = x - self.text_width / 2
        else:  # right
            self.insertion_x = x - self.text_width
        
        if self.style.vertical_align == "bottom":
            self.insertion_y = y
        elif self.style.vertical_align == "middle":
            self.insertion_y = y - self.text_height / 2
        else:  # top
            self.insertion_y = y - self.text_height
        
        # Bounding box with padding
        padding = self.style.background_padding if self.style.background_color else 0
        self.bounds = (
            self.insertion_x - padding,
            self.insertion_y - padding,
            self.insertion_x + self.text_width + padding,
            self.insertion_y + self.text_height + padding
        )
    
    def get_lines(self) -> List[str]:
        """Get individual text lines."""
        return self.text.split('\n')
    
    def get_line_position(self, line_index: int) -> Tuple[float, float]:
        """Get the position for a specific line of text."""
        line_y = self.insertion_y + (self.line_count - line_index - 1) * self.style.height * 1.2
        return (self.insertion_x, line_y)
    
    def set_text(self, text: str):
        """Update text content."""
        self.text = text
        self._calculate_bounds()
    
    def move_to(self, x: float, y: float):
        """Move label to new position."""
        self.position = (x, y)
        self._calculate_bounds()
    
    def rotate(self, angle: float):
        """Set label rotation in degrees."""
        self.rotation = angle
    
    def contains_point(self, x: float, y: float) -> bool:
        """Check if point is within text bounds."""
        return (self.bounds[0] <= x <= self.bounds[2] and 
                self.bounds[1] <= y <= self.bounds[3])
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "type": "TextLabel",
            "text": self.text,
            "position": self.position,
            "rotation": self.rotation,
            "style": self.style.to_dict(),
            "layer": self.layer,
            "visible": self.visible,
            "locked": self.locked,
            "bounds": self.bounds,
            "line_count": self.line_count,
        }


class LeaderLine:
    """
    Leader line connecting text to a point of interest.
    
    Supports straight lines, dogleg (elbow) leaders, and spline curves.
    Can have arrowheads at the landing point.
    
    Usage:
        # Straight leader
        leader = LeaderLine(
            start_point=(50.0, 50.0),
            end_point=(100.0, 100.0),
            text_label=label,
            has_arrowhead=True
        )
        
        # Dogleg leader
        leader = LeaderLine(
            start_point=(50.0, 50.0),
            end_point=(100.0, 100.0),
            leader_type="dogleg",
            dogleg_length=20.0,
            text_label=label
        )
    """
    
    def __init__(
        self,
        start_point: Tuple[float, float],
        end_point: Tuple[float, float],
        text_label: Optional[TextLabel] = None,
        leader_type: Literal["straight", "dogleg", "spline"] = "straight",
        has_arrowhead: bool = True,
        arrowhead_size: float = 2.5,
        arrowhead_style: Literal["closed", "open", "dot"] = "closed",
        dogleg_length: float = 10.0,
        dogleg_direction: Literal["horizontal", "vertical", "auto"] = "auto",
        style: Optional[Dict[str, Any]] = None,
        layer: str = "Annotations",
        id: Optional[str] = None
    ):
        self.id = id or str(uuid4())
        self.start_point = start_point  # Landing point (near feature)
        self.end_point = end_point      # Text attachment point
        self.text_label = text_label
        self.leader_type = leader_type
        self.has_arrowhead = has_arrowhead
        self.arrowhead_size = arrowhead_size
        self.arrowhead_style = arrowhead_style
        self.dogleg_length = dogleg_length
        self.dogleg_direction = dogleg_direction
        self.layer = layer
        self.visible = True
        self.locked = False
        
        # Line style
        self.style = style or {
            "color": "black",
            "line_weight": 0.25,
            "line_type": "continuous"
        }
        
        # Calculate path
        self._calculate_path()
    
    def _calculate_path(self):
        """Calculate the leader line path points."""
        x1, y1 = self.start_point
        x2, y2 = self.end_point
        
        if self.leader_type == "straight":
            self.path_points = [self.start_point, self.end_point]
        
        elif self.leader_type == "dogleg":
            # Calculate dogleg (elbow) point
            if self.dogleg_direction == "auto":
                # Auto-determine based on relative positions
                dx = abs(x2 - x1)
                dy = abs(y2 - y1)
                self.dogleg_direction = "horizontal" if dx > dy else "vertical"
            
            if self.dogleg_direction == "horizontal":
                # Horizontal then vertical
                dogleg_point = (x1 + self._sign(x2 - x1) * self.dogleg_length, y1)
            else:  # vertical
                # Vertical then horizontal
                dogleg_point = (x1, y1 + self._sign(y2 - y1) * self.dogleg_length)
            
            self.path_points = [self.start_point, dogleg_point, self.end_point]
        
        elif self.leader_type == "spline":
            # Control points for spline curve
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            offset_x = (y2 - y1) * 0.2
            offset_y = (x1 - x2) * 0.2
            
            control1 = (mid_x + offset_x, mid_y + offset_y)
            control2 = (mid_x - offset_x, mid_y - offset_y)
            
            self.path_points = [self.start_point, control1, control2, self.end_point]
        
        # Update text label position if attached
        if self.text_label:
            self.text_label.move_to(x2, y2)
    
    def _sign(self, value: float) -> int:
        """Return sign of value (-1, 0, or 1)."""
        if value > 0:
            return 1
        elif value < 0:
            return -1
        return 0
    
    def get_arrowhead_points(self) -> Optional[List[Tuple[float, float]]]:
        """Get arrowhead polygon points if enabled."""
        if not self.has_arrowhead:
            return None
        
        # Calculate arrowhead direction (from second point toward start)
        if len(self.path_points) < 2:
            return None
        
        x1, y1 = self.path_points[0]  # Landing point
        x2, y2 = self.path_points[1]  # Next point
        
        dx = x2 - x1
        dy = y2 - y1
        length = math.sqrt(dx**2 + dy**2)
        
        if length == 0:
            return None
        
        # Normalize direction
        ux, uy = dx / length, dy / length
        
        # Perpendicular vector
        px, py = -uy, ux
        
        size = self.arrowhead_size
        
        if self.arrowhead_style == "closed":
            # Triangle arrowhead
            tip = (x1, y1)
            base_x = x1 + ux * size
            base_y = y1 + uy * size
            
            return [
                tip,
                (base_x + px * size * 0.5, base_y + py * size * 0.5),
                (base_x - px * size * 0.5, base_y - py * size * 0.5),
                tip
            ]
        
        elif self.arrowhead_style == "open":
            # Two lines forming arrow
            tip = (x1, y1)
            base_x = x1 + ux * size
            base_y = y1 + uy * size
            
            return [
                (base_x + px * size * 0.5, base_y + py * size * 0.5),
                tip,
                (base_x - px * size * 0.5, base_y - py * size * 0.5)
            ]
        
        elif self.arrowhead_style == "dot":
            # Circle at landing point (return as special marker)
            return [(x1, y1, size * 0.5)]  # Special format: (x, y, radius)
        
        return None
    
    def get_segments(self) -> List[Tuple[Tuple[float, float], Tuple[float, float]]]:
        """Get line segments as list of (start, end) tuples."""
        segments = []
        for i in range(len(self.path_points) - 1):
            segments.append((self.path_points[i], self.path_points[i + 1]))
        return segments
    
    def get_total_length(self) -> float:
        """Calculate total leader line length."""
        length = 0.0
        for i in range(len(self.path_points) - 1):
            x1, y1 = self.path_points[i]
            x2, y2 = self.path_points[i + 1]
            length += math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        return length
    
    def attach_text(self, text_label: TextLabel, offset: Tuple[float, float] = (5.0, 0.0)):
        """Attach a text label to the leader end point."""
        self.text_label = text_label
        x, y = self.end_point
        ox, oy = offset
        text_label.move_to(x + ox, y + oy)
    
    def set_start_point(self, x: float, y: float):
        """Update landing point."""
        self.start_point = (x, y)
        self._calculate_path()
    
    def set_end_point(self, x: float, y: float):
        """Update text attachment point."""
        self.end_point = (x, y)
        self._calculate_path()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "type": "LeaderLine",
            "start_point": self.start_point,
            "end_point": self.end_point,
            "path_points": self.path_points,
            "leader_type": self.leader_type,
            "has_arrowhead": self.has_arrowhead,
            "arrowhead_size": self.arrowhead_size,
            "arrowhead_style": self.arrowhead_style,
            "style": self.style,
            "layer": self.layer,
            "visible": self.visible,
            "locked": self.locked,
            "text_label_id": self.text_label.id if self.text_label else None,
            "total_length": self.get_total_length(),
        }


class AnnotationGroup:
    """
    Group of related annotations (labels and leader lines).
    
    Allows multiple annotations to be managed as a single unit.
    
    Usage:
        group = AnnotationGroup(name="Room Labels")
        group.add_label(TextLabel(text="Kitchen", position=(100, 200)))
        group.add_leader(LeaderLine(...))
        group.visible = False  # Hide all
    """
    
    def __init__(self, name: str = "Annotation Group", id: Optional[str] = None):
        self.id = id or str(uuid4())
        self.name = name
        self.labels: List[TextLabel] = []
        self.leaders: List[LeaderLine] = []
        self._visible = True
        self.locked = False
    
    @property
    def visible(self) -> bool:
        return self._visible
    
    @visible.setter
    def visible(self, value: bool):
        self._visible = value
        for label in self.labels:
            label.visible = value
        for leader in self.leaders:
            leader.visible = value
    
    def add_label(self, label: TextLabel):
        """Add a text label to the group."""
        self.labels.append(label)
        label.visible = self._visible
    
    def add_leader(self, leader: LeaderLine):
        """Add a leader line to the group."""
        self.leaders.append(leader)
        leader.visible = self._visible
    
    def remove_label(self, label_id: str) -> bool:
        """Remove a label by ID."""
        for i, label in enumerate(self.labels):
            if label.id == label_id:
                self.labels.pop(i)
                return True
        return False
    
    def remove_leader(self, leader_id: str) -> bool:
        """Remove a leader line by ID."""
        for i, leader in enumerate(self.leaders):
            if leader.id == leader_id:
                self.leaders.pop(i)
                return True
        return False
    
    def move(self, dx: float, dy: float):
        """Move all annotations by offset."""
        for label in self.labels:
            x, y = label.position
            label.move_to(x + dx, y + dy)
        for leader in self.leaders:
            sx, sy = leader.start_point
            ex, ey = leader.end_point
            leader.set_start_point(sx + dx, sy + dy)
            leader.set_end_point(ex + dx, ey + dy)
    
    def get_bounds(self) -> Tuple[float, float, float, float]:
        """Get bounding box of all annotations."""
        if not self.labels and not self.leaders:
            return (0, 0, 0, 0)
        
        min_x = float('inf')
        min_y = float('inf')
        max_x = float('-inf')
        max_y = float('-inf')
        
        for label in self.labels:
            bounds = label.bounds
            min_x = min(min_x, bounds[0])
            min_y = min(min_y, bounds[1])
            max_x = max(max_x, bounds[2])
            max_y = max(max_y, bounds[3])
        
        for leader in self.leaders:
            for point in leader.path_points:
                min_x = min(min_x, point[0])
                min_y = min(min_y, point[1])
                max_x = max(max_x, point[0])
                max_y = max(max_y, point[1])
        
        return (min_x, min_y, max_x, max_y)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "visible": self._visible,
            "locked": self.locked,
            "labels": [label.to_dict() for label in self.labels],
            "leaders": [leader.to_dict() for leader in self.leaders],
            "bounds": self.get_bounds(),
        }
