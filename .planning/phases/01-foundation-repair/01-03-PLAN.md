---
phase: 01-foundation-repair
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - core/ceiling_panel_calc.py
  - core/svg_config.py
  - requirements.txt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "DXF files open correctly in AutoCAD without errors"
    - "SVG scale is configurable (screen, print, high-res)"
    - "export_json() returns the project data dictionary"
    - "ezdxf is a required dependency (no broken fallback)"
  artifacts:
    - path: "core/ceiling_panel_calc.py"
      provides: "Fixed DXFGenerator, SVGGenerator, ProjectExporter"
      contains: "return project_data"
    - path: "core/svg_config.py"
      provides: "SVGConfig dataclass with scale presets"
      exports: ["SVGConfig"]
    - path: "requirements.txt"
      provides: "Updated dependencies including ezdxf"
      contains: "ezdxf"
  key_links:
    - from: "core/ceiling_panel_calc.py"
      to: "core/svg_config.py"
      via: "import SVGConfig"
      pattern: "from core.svg_config import SVGConfig"
---

<objective>
Fix all export generators: DXF, SVG, and JSON.

Purpose: DXF manual fallback is incomplete and produces invalid files. SVG has hardcoded scale that doesn't work for different outputs. JSON export doesn't return data. These issues break the professional workflow.

Output: Working export generators that produce valid CAD files, configurable SVG output, and JSON export with return value.
</objective>

<execution_context>
@/home/tomas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/tomas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-repair/01-RESEARCH.md
@core/ceiling_panel_calc.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DXF generator - require ezdxf, remove broken fallback</name>
  <files>core/ceiling_panel_calc.py, requirements.txt</files>
  <action>
**Step 1: Update requirements.txt to include ezdxf as required:**

Add to requirements.txt:
```
ezdxf>=1.0.0
```

**Step 2: Modify DXFGenerator in core/ceiling_panel_calc.py:**

Replace the current DXFGenerator class (lines 139-228) with:

```python
class DXFGenerator:
    """Generate DXF files for CAD integration.
    
    Requires ezdxf library: pip install ezdxf
    """
    
    def __init__(self, ceiling: CeilingDimensions, spacing: PanelSpacing, layout: PanelLayout):
        self.ceiling = ceiling
        self.spacing = spacing
        self.layout = layout
        
        # Verify ezdxf is available at init time
        try:
            import ezdxf
            self._ezdxf = ezdxf
        except ImportError:
            raise ImportError(
                "ezdxf is required for DXF generation. "
                "Install with: pip install ezdxf"
            )
    
    def generate_dxf(self, filename: str, material: Optional[Material] = None) -> str:
        """
        Generate a DXF file with ceiling layout.
        
        Args:
            filename: Output file path
            material: Optional material specification for annotations
            
        Returns:
            Path to generated file
        """
        doc = self._ezdxf.new(dxfversion='R2010')
        
        # Create layers for organization
        doc.layers.add('CEILING_BOUNDARY', color=7)  # White
        doc.layers.add('PANELS', color=1)            # Red
        doc.layers.add('PERIMETER_GAP', color=2)     # Yellow
        doc.layers.add('ANNOTATIONS', color=3)       # Green
        
        msp = doc.modelspace()
        
        # Draw ceiling boundary
        msp.add_lwpolyline([
            (0, 0),
            (self.ceiling.length_mm, 0),
            (self.ceiling.length_mm, self.ceiling.width_mm),
            (0, self.ceiling.width_mm),
            (0, 0)
        ], close=True, dxfattribs={'layer': 'CEILING_BOUNDARY'})
        
        # Draw perimeter gap indicator
        perimeter = self.spacing.perimeter_gap_mm
        msp.add_lwpolyline([
            (perimeter, perimeter),
            (self.ceiling.length_mm - perimeter, perimeter),
            (self.ceiling.length_mm - perimeter, self.ceiling.width_mm - perimeter),
            (perimeter, self.ceiling.width_mm - perimeter),
            (perimeter, perimeter)
        ], close=True, dxfattribs={'layer': 'PERIMETER_GAP'})
        
        # Draw panels
        start_x = self.spacing.perimeter_gap_mm
        start_y = self.spacing.perimeter_gap_mm
        
        for row in range(self.layout.panels_per_column):
            for col in range(self.layout.panels_per_row):
                x = start_x + col * (self.layout.panel_width_mm + self.spacing.panel_gap_mm)
                y = start_y + row * (self.layout.panel_length_mm + self.spacing.panel_gap_mm)
                
                # Draw panel rectangle
                msp.add_lwpolyline([
                    (x, y),
                    (x + self.layout.panel_width_mm, y),
                    (x + self.layout.panel_width_mm, y + self.layout.panel_length_mm),
                    (x, y + self.layout.panel_length_mm),
                    (x, y)
                ], close=True, dxfattribs={'layer': 'PANELS'})
                
                # Add panel label at center
                panel_num = row * self.layout.panels_per_row + col + 1
                label_x = x + self.layout.panel_width_mm / 2
                label_y = y + self.layout.panel_length_mm / 2
                msp.add_text(
                    f"P{panel_num}",
                    dxfattribs={
                        'layer': 'ANNOTATIONS',
                        'height': min(50, self.layout.panel_width_mm / 10),
                        'insert': (label_x, label_y)
                    }
                )
        
        # Add title block annotations
        title_y = self.ceiling.width_mm + 100
        msp.add_text(
            f"Ceiling: {self.ceiling.length_mm}mm x {self.ceiling.width_mm}mm",
            dxfattribs={'layer': 'ANNOTATIONS', 'height': 80, 'insert': (0, title_y)}
        )
        msp.add_text(
            f"Panels: {self.layout.total_panels} ({self.layout.panels_per_row}x{self.layout.panels_per_column})",
            dxfattribs={'layer': 'ANNOTATIONS', 'height': 80, 'insert': (0, title_y + 100)}
        )
        msp.add_text(
            f"Panel Size: {self.layout.panel_width_mm:.1f}mm x {self.layout.panel_length_mm:.1f}mm",
            dxfattribs={'layer': 'ANNOTATIONS', 'height': 80, 'insert': (0, title_y + 200)}
        )
        
        if material:
            msp.add_text(
                f"Material: {material.name} - {material.color}",
                dxfattribs={'layer': 'ANNOTATIONS', 'height': 80, 'insert': (0, title_y + 300)}
            )
        
        doc.saveas(filename)
        print(f"✓ DXF saved: {filename}")
        return filename
```

Key changes:
- ezdxf import at __init__ with clear error if missing
- Remove _generate_dxf_manual fallback entirely
- Add proper layer organization (CEILING_BOUNDARY, PANELS, PERIMETER_GAP, ANNOTATIONS)
- Return filename for chaining
- Panel labels positioned at center
- Title block with specifications
  </action>
  <verify>
```bash
# Ensure ezdxf is installed
pip install ezdxf --quiet

# Test DXF generation
python -c "
from core.ceiling_panel_calc import (
    CeilingDimensions, PanelSpacing, PanelLayout, DXFGenerator
)

ceiling = CeilingDimensions(length_mm=6000, width_mm=4500)
spacing = PanelSpacing(perimeter_gap_mm=200, panel_gap_mm=200)
layout = PanelLayout(
    panel_width_mm=800, panel_length_mm=800,
    panels_per_row=6, panels_per_column=5,
    total_panels=30, total_coverage_sqm=19.2, gap_area_sqm=7.8
)

dxf_gen = DXFGenerator(ceiling, spacing, layout)
result = dxf_gen.generate_dxf('test_output.dxf')
print(f'Generated: {result}')

# Verify file exists and has content
import os
assert os.path.exists('test_output.dxf'), 'DXF not created'
size = os.path.getsize('test_output.dxf')
assert size > 1000, f'DXF too small ({size} bytes), likely invalid'
print(f'DXF size: {size} bytes - looks valid')

# Clean up
os.remove('test_output.dxf')
"
```
  </verify>
  <done>
    - DXFGenerator requires ezdxf (fails fast with clear error if missing)
    - No broken manual fallback
    - DXF files have proper layer organization
    - generate_dxf returns filename
  </done>
</task>

<task type="auto">
  <name>Task 2: Create configurable SVG generator</name>
  <files>core/svg_config.py, core/ceiling_panel_calc.py</files>
  <action>
**Step 1: Create core/svg_config.py:**

```python
"""SVG generation configuration."""

from dataclasses import dataclass
from typing import Literal


@dataclass
class SVGConfig:
    """Configuration for SVG output generation.
    
    The scale factor converts mm to pixels. Different targets need different scales:
    - screen: 0.5 (96 DPI display)
    - print: 0.352 (72 DPI print)
    - high_res: 0.705 (144 DPI retina/high-res)
    """
    
    scale: float = 0.5
    target: Literal['screen', 'print', 'high_res', 'custom'] = 'screen'
    
    # Colors
    ceiling_fill: str = "#f0f0f0"
    ceiling_stroke: str = "#333333"
    panel_fill: str = "#e8f4f8"
    panel_stroke: str = "#0066cc"
    gap_stroke: str = "#999999"
    text_color: str = "#333333"
    
    # Styling
    stroke_width: float = 1.5
    font_size: int = 10
    font_family: str = "Arial, sans-serif"
    
    def __post_init__(self):
        """Auto-set scale based on target if not custom."""
        scale_map = {
            'screen': 0.5,
            'print': 0.352,
            'high_res': 0.705,
        }
        if self.target != 'custom' and self.target in scale_map:
            self.scale = scale_map[self.target]
    
    @classmethod
    def for_screen(cls) -> 'SVGConfig':
        """Create config optimized for screen display."""
        return cls(target='screen')
    
    @classmethod
    def for_print(cls) -> 'SVGConfig':
        """Create config optimized for printing."""
        return cls(target='print', stroke_width=0.5)
    
    @classmethod
    def for_high_res(cls) -> 'SVGConfig':
        """Create config optimized for high-resolution displays."""
        return cls(target='high_res')
```

**Step 2: Update SVGGenerator in core/ceiling_panel_calc.py:**

Replace the SVGGenerator class (lines 231-316) with:

```python
from core.svg_config import SVGConfig

class SVGGenerator:
    """Generate SVG blueprints for visualization."""
    
    def __init__(
        self, 
        ceiling: CeilingDimensions, 
        spacing: PanelSpacing, 
        layout: PanelLayout,
        config: SVGConfig = None
    ):
        self.ceiling = ceiling
        self.spacing = spacing
        self.layout = layout
        self.config = config or SVGConfig()
    
    def generate_svg(self, filename: str, material: Optional[Material] = None) -> str:
        """Generate SVG blueprint with top-down view.
        
        Args:
            filename: Output file path
            material: Optional material for annotations
            
        Returns:
            Path to generated file
        """
        cfg = self.config
        scale = cfg.scale
        
        # Calculate dimensions
        width_px = self.ceiling.length_mm * scale
        height_px = self.ceiling.width_mm * scale
        
        # Build SVG with proper viewBox
        svg_lines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            f'<svg width="{width_px:.1f}px" height="{height_px:.1f}px"',
            f'     viewBox="0 0 {self.ceiling.length_mm} {self.ceiling.width_mm}"',
            f'     xmlns="http://www.w3.org/2000/svg">',
            '<defs>',
            '<style>',
            f'.ceiling {{ fill: {cfg.ceiling_fill}; stroke: {cfg.ceiling_stroke}; stroke-width: {cfg.stroke_width * 2}; }}',
            f'.panel {{ fill: {cfg.panel_fill}; stroke: {cfg.panel_stroke}; stroke-width: {cfg.stroke_width}; }}',
            f'.gap {{ fill: none; stroke: {cfg.gap_stroke}; stroke-width: {cfg.stroke_width / 2}; stroke-dasharray: 10,5; }}',
            f'.text {{ font-family: {cfg.font_family}; font-size: {cfg.font_size * 5}px; fill: {cfg.text_color}; }}',
            f'.text-small {{ font-family: {cfg.font_family}; font-size: {cfg.font_size * 3}px; fill: {cfg.text_color}; }}',
            '</style>',
            '</defs>',
            '',
            '<!-- Ceiling boundary -->',
            f'<rect class="ceiling" x="0" y="0" width="{self.ceiling.length_mm}" height="{self.ceiling.width_mm}"/>',
        ]
        
        # Perimeter gap indicator
        perim = self.spacing.perimeter_gap_mm
        svg_lines.append(
            f'<rect class="gap" x="{perim}" y="{perim}" '
            f'width="{self.ceiling.length_mm - 2*perim}" height="{self.ceiling.width_mm - 2*perim}"/>'
        )
        
        # Draw panels (using mm coordinates, viewBox handles scaling)
        start_x = self.spacing.perimeter_gap_mm
        start_y = self.spacing.perimeter_gap_mm
        panel_w = self.layout.panel_width_mm
        panel_h = self.layout.panel_length_mm
        gap = self.spacing.panel_gap_mm
        
        svg_lines.append('')
        svg_lines.append('<!-- Panels -->')
        svg_lines.append('<g id="panels">')
        
        for row in range(self.layout.panels_per_column):
            for col in range(self.layout.panels_per_row):
                x = start_x + col * (panel_w + gap)
                y = start_y + row * (panel_h + gap)
                panel_num = row * self.layout.panels_per_row + col + 1
                
                svg_lines.append(
                    f'  <rect class="panel" x="{x:.1f}" y="{y:.1f}" '
                    f'width="{panel_w:.1f}" height="{panel_h:.1f}"/>'
                )
                
                # Panel label (centered)
                label_x = x + panel_w / 2
                label_y = y + panel_h / 2
                svg_lines.append(
                    f'  <text class="text-small" x="{label_x:.1f}" y="{label_y:.1f}" '
                    f'text-anchor="middle" dominant-baseline="middle">P{panel_num}</text>'
                )
        
        svg_lines.append('</g>')
        
        # Annotations
        svg_lines.append('')
        svg_lines.append('<!-- Annotations -->')
        svg_lines.append('<g id="annotations">')
        svg_lines.append(
            f'<text class="text" x="50" y="100" font-weight="bold">'
            f'Ceiling: {self.ceiling.length_mm}mm x {self.ceiling.width_mm}mm</text>'
        )
        svg_lines.append(
            f'<text class="text" x="50" y="180">'
            f'Panels: {self.layout.panel_width_mm:.0f}mm x {self.layout.panel_length_mm:.0f}mm '
            f'({self.layout.panels_per_row}x{self.layout.panels_per_column})</text>'
        )
        svg_lines.append(
            f'<text class="text" x="50" y="260">'
            f'Gap: {self.spacing.panel_gap_mm}mm | Perimeter: {self.spacing.perimeter_gap_mm}mm</text>'
        )
        
        if material:
            svg_lines.append(
                f'<text class="text" x="50" y="340">'
                f'Material: {material.name} - {material.color}</text>'
            )
        
        svg_lines.append('</g>')
        svg_lines.append('</svg>')
        
        with open(filename, 'w') as f:
            f.write('\n'.join(svg_lines))
        
        print(f"✓ SVG saved: {filename}")
        return filename
```

Key changes:
- Accept optional SVGConfig parameter
- Use viewBox for proper scaling (coordinates in mm, viewBox handles display)
- Configurable colors and styles
- Return filename for chaining
- Proper SVG structure with groups
  </action>
  <verify>
```bash
python -c "
from core.ceiling_panel_calc import (
    CeilingDimensions, PanelSpacing, PanelLayout, SVGGenerator
)
from core.svg_config import SVGConfig

ceiling = CeilingDimensions(length_mm=6000, width_mm=4500)
spacing = PanelSpacing(perimeter_gap_mm=200, panel_gap_mm=200)
layout = PanelLayout(
    panel_width_mm=800, panel_length_mm=800,
    panels_per_row=6, panels_per_column=5,
    total_panels=30, total_coverage_sqm=19.2, gap_area_sqm=7.8
)

# Test different configs
for name, config in [
    ('screen', SVGConfig.for_screen()),
    ('print', SVGConfig.for_print()),
    ('high_res', SVGConfig.for_high_res()),
]:
    svg_gen = SVGGenerator(ceiling, spacing, layout, config=config)
    result = svg_gen.generate_svg(f'test_{name}.svg')
    print(f'{name}: scale={config.scale}')

# Verify files exist
import os
for name in ['screen', 'print', 'high_res']:
    fname = f'test_{name}.svg'
    assert os.path.exists(fname), f'{fname} not created'
    os.remove(fname)

print('SVG generation with configs works')
"
```
  </verify>
  <done>
    - SVGConfig dataclass with screen/print/high_res presets
    - SVGGenerator accepts optional config
    - viewBox used for proper scaling
    - generate_svg returns filename
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix ProjectExporter.export_json to return data</name>
  <files>core/ceiling_panel_calc.py</files>
  <action>
Fix the export_json method in ProjectExporter class (lines 471-502) to return the project_data dictionary.

Find this method:
```python
def export_json(self, filename: str):
    """Export project as JSON for further processing"""
    project_data = {
        ...
    }
    
    with open(filename, 'w') as f:
        json.dump(project_data, f, indent=2)
    
    print(f"✓ JSON export saved: {filename}")
```

Change to:
```python
def export_json(self, filename: str) -> Dict[str, Any]:
    """Export project as JSON for further processing.
    
    Args:
        filename: Output file path
        
    Returns:
        Dictionary containing all project data
    """
    project_data = {
        'metadata': {
            'generated': datetime.now().isoformat(),
            'application': 'Ceiling Panel Calculator',
            'version': '1.0.0'
        },
        'ceiling': {
            'length_mm': self.ceiling.length_mm,
            'width_mm': self.ceiling.width_mm,
            'area_m2': self.ceiling.length_mm * self.ceiling.width_mm / 1_000_000
        },
        'spacing': {
            'perimeter_gap_mm': self.spacing.perimeter_gap_mm,
            'panel_gap_mm': self.spacing.panel_gap_mm
        },
        'layout': self.layout.to_dict(),
        'material': {
            'name': self.material.name,
            'category': self.material.category,
            'color': self.material.color,
            'reflectivity': self.material.reflectivity,
            'cost_per_m2': self.material.cost_per_sqm,
            'notes': self.material.notes,
            'total_cost': self.layout.total_coverage_sqm * self.material.cost_per_sqm
        }
    }
    
    with open(filename, 'w') as f:
        json.dump(project_data, f, indent=2)
    
    print(f"✓ JSON export saved: {filename}")
    return project_data  # <-- ADD THIS LINE
```

Also update the type hint import at top of file:
```python
from typing import List, Tuple, Dict, Optional, Any
```
  </action>
  <verify>
```bash
python -c "
from core.ceiling_panel_calc import (
    CeilingDimensions, PanelSpacing, PanelLayout, 
    Material, ProjectExporter
)

ceiling = CeilingDimensions(length_mm=6000, width_mm=4500)
spacing = PanelSpacing(perimeter_gap_mm=200, panel_gap_mm=200)
layout = PanelLayout(
    panel_width_mm=800, panel_length_mm=800,
    panels_per_row=6, panels_per_column=5,
    total_panels=30, total_coverage_sqm=19.2, gap_area_sqm=7.8
)
material = Material(
    name='Test Panel', category='test', color='White',
    reflectivity=0.8, cost_per_sqm=100.0
)

exporter = ProjectExporter(ceiling, spacing, layout, material)
result = exporter.export_json('test_export.json')

# Verify return value
assert result is not None, 'export_json returned None'
assert isinstance(result, dict), f'Expected dict, got {type(result)}'
assert 'ceiling' in result, 'Missing ceiling key'
assert 'layout' in result, 'Missing layout key'
assert result['ceiling']['length_mm'] == 6000, 'Wrong length'

print(f'export_json returns dict with keys: {list(result.keys())}')

# Clean up
import os
os.remove('test_export.json')
print('PASS: export_json returns project data')
"
```
  </verify>
  <done>
    - export_json() returns Dict[str, Any]
    - Return value contains ceiling, spacing, layout, material data
    - Method signature includes return type hint
  </done>
</task>

</tasks>

<verification>
1. DXF generation with ezdxf:
   ```bash
   python -c "
   from core.ceiling_panel_calc import CeilingDimensions, PanelSpacing, CeilingPanelCalculator, DXFGenerator
   ceiling = CeilingDimensions(6000, 4500)
   spacing = PanelSpacing(200, 200)
   calc = CeilingPanelCalculator(ceiling, spacing)
   layout = calc.calculate_optimal_layout()
   dxf = DXFGenerator(ceiling, spacing, layout)
   dxf.generate_dxf('test.dxf')
   import os; assert os.path.getsize('test.dxf') > 1000; os.remove('test.dxf')
   print('DXF OK')
   "
   ```

2. SVG with configurable scale:
   ```bash
   python -c "
   from core.svg_config import SVGConfig
   cfg = SVGConfig.for_print()
   assert cfg.scale == 0.352, f'Wrong print scale: {cfg.scale}'
   print('SVG Config OK')
   "
   ```

3. JSON export returns data:
   ```bash
   python -c "
   from core.ceiling_panel_calc import *
   exp = ProjectExporter(
       CeilingDimensions(6000, 4500),
       PanelSpacing(200, 200),
       PanelLayout(800, 800, 6, 5, 30, 19.2, 7.8),
       MaterialLibrary.get_material('led_panel_white')
   )
   data = exp.export_json('/tmp/test.json')
   assert data is not None and 'layout' in data
   import os; os.remove('/tmp/test.json')
   print('JSON export returns data OK')
   "
   ```
</verification>

<success_criteria>
- [ ] DXFGenerator requires ezdxf (no broken fallback)
- [ ] DXF files have layer organization (CEILING_BOUNDARY, PANELS, etc.)
- [ ] SVGConfig provides scale presets (screen, print, high_res)
- [ ] SVGGenerator accepts optional SVGConfig
- [ ] SVG uses viewBox for proper scaling
- [ ] export_json() returns project data dictionary
- [ ] requirements.txt includes ezdxf>=1.0.0
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-repair/01-03-SUMMARY.md`
</output>
