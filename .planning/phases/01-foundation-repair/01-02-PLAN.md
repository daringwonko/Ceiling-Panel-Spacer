---
phase: 01-foundation-repair
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - core/validation.py
  - core/config.py
  - core/exceptions.py
  - api/middleware/auth.py
  - .env.example
  - .gitignore
autonomous: true
user_setup:
  - service: environment
    why: "Secrets must be configured via environment variables"
    env_vars:
      - name: JWT_SECRET
        source: "Generate with: python -c \"import secrets; print(secrets.token_urlsafe(32))\""
      - name: SECRET_KEY
        source: "Generate with: python -c \"import secrets; print(secrets.token_urlsafe(32))\""

must_haves:
  truths:
    - "Invalid dimensions (negative, zero, too large) raise ValidationError"
    - "Error messages clearly state what's wrong and valid ranges"
    - "JWT secrets loaded from environment, not hardcoded"
    - ".env file is gitignored"
  artifacts:
    - path: "core/validation.py"
      provides: "Pydantic dataclasses for CeilingDimensions, PanelSpacing"
      exports: ["CeilingDimensions", "PanelSpacing"]
    - path: "core/config.py"
      provides: "Settings class with environment loading"
      exports: ["settings"]
    - path: "core/exceptions.py"
      provides: "Custom exception hierarchy"
      exports: ["BuildScaleError", "ValidationError", "CalculationError"]
    - path: ".env.example"
      provides: "Template for required environment variables"
      contains: "JWT_SECRET"
  key_links:
    - from: "api/middleware/auth.py"
      to: "core/config.py"
      via: "settings.jwt_secret"
      pattern: "from core.config import settings"
---

<objective>
Create robust input validation and secure configuration management.

Purpose: The current dataclasses have no validation - users can pass negative dimensions, gaps larger than ceilings, etc. JWT secrets are hardcoded with a default fallback. This creates both usability and security issues.

Output: Pydantic-based validation with clear error messages, and environment-based secret management with pydantic-settings.
</objective>

<execution_context>
@/home/tomas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/tomas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-repair/01-RESEARCH.md
@core/ceiling_panel_calc.py
@api/middleware/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom exceptions and validation layer</name>
  <files>core/exceptions.py, core/validation.py</files>
  <action>
**Step 1: Create core/exceptions.py:**

```python
"""Custom exceptions for BuildScale platform."""

from typing import Dict, Any, Optional


class BuildScaleError(Exception):
    """Base exception for all BuildScale errors."""
    
    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.message = message
        self.details = details or {}
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "error": self.__class__.__name__,
            "message": self.message,
            "details": self.details
        }


class ValidationError(BuildScaleError):
    """Raised when input validation fails."""
    pass


class CalculationError(BuildScaleError):
    """Raised when panel calculation fails."""
    pass


class ExportError(BuildScaleError):
    """Raised when file export fails."""
    pass


class ConfigurationError(BuildScaleError):
    """Raised when configuration is invalid or missing."""
    pass
```

**Step 2: Create core/validation.py with Pydantic dataclasses:**

```python
"""Validated data structures for ceiling panel calculations."""

from pydantic import field_validator, model_validator
from pydantic.dataclasses import dataclass
from typing import Tuple

from core.exceptions import ValidationError


@dataclass
class CeilingDimensions:
    """Ceiling dimensions in millimeters with validation."""
    
    length_mm: float  # X-axis
    width_mm: float   # Y-axis
    
    @field_validator('length_mm', 'width_mm', mode='before')
    @classmethod
    def validate_dimension(cls, v: float, info) -> float:
        """Validate dimension is positive and within reasonable bounds."""
        try:
            v = float(v)
        except (TypeError, ValueError):
            raise ValueError(f"Dimension must be a number, got {type(v).__name__}")
        
        if v <= 0:
            raise ValueError(f"Dimension must be positive, got {v}mm")
        if v > 50000:  # 50m max
            raise ValueError(f"Dimension exceeds maximum (50000mm/50m), got {v}mm")
        if v < 100:  # 10cm min
            raise ValueError(f"Dimension below minimum (100mm/10cm), got {v}mm")
        return v
    
    def to_meters(self) -> Tuple[float, float]:
        """Convert dimensions to meters."""
        return self.length_mm / 1000, self.width_mm / 1000
    
    @property
    def area_sqm(self) -> float:
        """Calculate area in square meters."""
        return (self.length_mm * self.width_mm) / 1_000_000


@dataclass
class PanelSpacing:
    """Gap specifications in millimeters with validation."""
    
    perimeter_gap_mm: float  # Gap around ceiling edge
    panel_gap_mm: float      # Gap between panels
    
    @field_validator('perimeter_gap_mm', 'panel_gap_mm', mode='before')
    @classmethod
    def validate_gap(cls, v: float) -> float:
        """Validate gap is non-negative and reasonable."""
        try:
            v = float(v)
        except (TypeError, ValueError):
            raise ValueError(f"Gap must be a number, got {type(v).__name__}")
        
        if v < 0:
            raise ValueError(f"Gap cannot be negative, got {v}mm")
        if v > 1000:  # 1m max gap
            raise ValueError(f"Gap exceeds maximum (1000mm/1m), got {v}mm")
        return v


def validate_ceiling_vs_spacing(
    ceiling: CeilingDimensions, 
    spacing: PanelSpacing
) -> None:
    """Validate that spacing makes sense for the given ceiling."""
    available_length = ceiling.length_mm - (2 * spacing.perimeter_gap_mm)
    available_width = ceiling.width_mm - (2 * spacing.perimeter_gap_mm)
    
    if available_length <= 0:
        raise ValidationError(
            f"Perimeter gap ({spacing.perimeter_gap_mm}mm x 2 = {spacing.perimeter_gap_mm * 2}mm) "
            f"exceeds ceiling length ({ceiling.length_mm}mm)",
            details={
                "ceiling_length_mm": ceiling.length_mm,
                "perimeter_gap_mm": spacing.perimeter_gap_mm,
                "required_minimum_length": spacing.perimeter_gap_mm * 2 + 100
            }
        )
    
    if available_width <= 0:
        raise ValidationError(
            f"Perimeter gap ({spacing.perimeter_gap_mm}mm x 2 = {spacing.perimeter_gap_mm * 2}mm) "
            f"exceeds ceiling width ({ceiling.width_mm}mm)",
            details={
                "ceiling_width_mm": ceiling.width_mm,
                "perimeter_gap_mm": spacing.perimeter_gap_mm,
                "required_minimum_width": spacing.perimeter_gap_mm * 2 + 100
            }
        )
```

Note: This requires adding pydantic to requirements.txt. Also update __init__.py exports.
  </action>
  <verify>
```bash
# First, ensure pydantic is available (may need to install)
pip show pydantic || pip install pydantic pydantic-settings

# Test validation
python -c "
from core.validation import CeilingDimensions, PanelSpacing, validate_ceiling_vs_spacing
from core.exceptions import ValidationError

# Valid input
ceiling = CeilingDimensions(length_mm=6000, width_mm=4500)
spacing = PanelSpacing(perimeter_gap_mm=200, panel_gap_mm=200)
print(f'Valid: {ceiling.length_mm}x{ceiling.width_mm}mm, area={ceiling.area_sqm:.2f}mÂ²')

# Invalid: negative dimension
try:
    bad = CeilingDimensions(length_mm=-100, width_mm=1000)
except Exception as e:
    print(f'Caught negative: {e}')

# Invalid: gap too large
try:
    ceiling = CeilingDimensions(length_mm=500, width_mm=500)
    spacing = PanelSpacing(perimeter_gap_mm=300, panel_gap_mm=50)
    validate_ceiling_vs_spacing(ceiling, spacing)
except ValidationError as e:
    print(f'Caught gap error: {e.message}')

print('Validation tests passed')
"
```
  </verify>
  <done>
    - core/exceptions.py exists with BuildScaleError, ValidationError, CalculationError
    - core/validation.py exists with validated CeilingDimensions, PanelSpacing
    - Invalid inputs raise clear error messages with details
  </done>
</task>

<task type="auto">
  <name>Task 2: Create secure configuration management</name>
  <files>core/config.py, .env.example, .gitignore</files>
  <action>
**Step 1: Create core/config.py with pydantic-settings:**

```python
"""Application configuration with environment variable loading."""

import os
from typing import Optional
from pydantic import SecretStr, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

from core.exceptions import ConfigurationError


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""
    
    model_config = SettingsConfigDict(
        env_file='.env',
        env_file_encoding='utf-8',
        extra='ignore',
        case_sensitive=False
    )
    
    # JWT Settings (REQUIRED in production)
    jwt_secret: SecretStr = SecretStr("CHANGE-ME-IN-PRODUCTION")
    jwt_algorithm: str = "HS256"
    jwt_expiration_hours: int = 24
    
    # Application secrets
    secret_key: SecretStr = SecretStr("CHANGE-ME-IN-PRODUCTION")
    
    # Database (optional for now)
    database_url: str = "sqlite:///./buildscale.db"
    
    # Application settings
    debug: bool = False
    log_level: str = "INFO"
    
    # Algorithm defaults
    max_panel_dimension_mm: float = 2400
    min_panel_dimension_mm: float = 300
    
    @field_validator('jwt_secret', 'secret_key', mode='after')
    @classmethod
    def warn_default_secrets(cls, v: SecretStr) -> SecretStr:
        """Warn if using default secrets."""
        if v.get_secret_value() == "CHANGE-ME-IN-PRODUCTION":
            import warnings
            warnings.warn(
                "Using default secret - set JWT_SECRET and SECRET_KEY environment variables!",
                UserWarning
            )
        return v
    
    def validate_production(self) -> None:
        """Validate settings are production-ready."""
        issues = []
        
        if self.jwt_secret.get_secret_value() == "CHANGE-ME-IN-PRODUCTION":
            issues.append("JWT_SECRET not configured")
        if self.secret_key.get_secret_value() == "CHANGE-ME-IN-PRODUCTION":
            issues.append("SECRET_KEY not configured")
        
        if issues and not self.debug:
            raise ConfigurationError(
                "Production configuration incomplete",
                details={"missing": issues}
            )


# Global settings instance (lazy loaded)
_settings: Optional[Settings] = None


def get_settings() -> Settings:
    """Get application settings (singleton)."""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings


# Convenience alias
settings = get_settings()
```

**Step 2: Create .env.example:**

```bash
# BuildScale Configuration
# Copy this file to .env and fill in your values

# REQUIRED: JWT Authentication
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
JWT_SECRET=your-super-secret-jwt-key-here
JWT_ALGORITHM=HS256
JWT_EXPIRATION_HOURS=24

# REQUIRED: Application secret key
# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
SECRET_KEY=your-super-secret-app-key-here

# Database connection
DATABASE_URL=sqlite:///./buildscale.db

# Application settings
DEBUG=false
LOG_LEVEL=INFO

# Algorithm defaults
MAX_PANEL_DIMENSION_MM=2400
MIN_PANEL_DIMENSION_MM=300
```

**Step 3: Update .gitignore to include .env:**

Add to existing .gitignore:
```
# Secrets - NEVER commit these
.env
.env.local
.env.production
*.pem
*.key

# Already exists but verify:
__pycache__/
*.py[cod]
```
  </action>
  <verify>
```bash
# Check .env.example exists and contains JWT_SECRET
grep "JWT_SECRET" .env.example && echo ".env.example OK"

# Check .gitignore includes .env
grep "^\.env$" .gitignore && echo ".gitignore OK"

# Test settings loading
python -c "
from core.config import get_settings
settings = get_settings()
print(f'JWT Algorithm: {settings.jwt_algorithm}')
print(f'Debug: {settings.debug}')
print(f'Max panel: {settings.max_panel_dimension_mm}mm')
print('Settings loaded OK')
"
```
  </verify>
  <done>
    - core/config.py exists with Settings class using pydantic-settings
    - .env.example documents all required environment variables
    - .gitignore includes .env to prevent secret commits
  </done>
</task>

<task type="auto">
  <name>Task 3: Update auth middleware to use secure config</name>
  <files>api/middleware/auth.py</files>
  <action>
Modify api/middleware/auth.py to use the new config system instead of hardcoded secrets.

**Changes to make:**

1. Remove the hardcoded JWT_SECRET line (line 14):
```python
# REMOVE THIS:
JWT_SECRET = os.getenv("JWT_SECRET", "ceiling-panel-calculator-secret-key-change-in-production")
```

2. Import settings at the top:
```python
from core.config import settings
```

3. Update JWTManager to use settings:
```python
class JWTManager:
    """JWT token management."""

    def __init__(self, secret: str = None, algorithm: str = None):
        self.secret = secret or settings.jwt_secret.get_secret_value()
        self.algorithm = algorithm or settings.jwt_algorithm
```

4. Update the global instance:
```python
# Global JWT manager instance (uses settings)
_jwt_manager = JWTManager()
```

5. Remove the module-level JWT_ALGORITHM and JWT_EXPIRATION_HOURS constants - use settings instead.

The key changes:
- Line 14: Delete hardcoded JWT_SECRET
- Line 15-16: Delete JWT_ALGORITHM, JWT_EXPIRATION_HOURS constants
- Add import: `from core.config import settings`
- Line 54-56: Use `settings.jwt_secret.get_secret_value()` and `settings.jwt_algorithm`
- Line 64-65: Use `settings.jwt_expiration_hours`
  </action>
  <verify>
```bash
python -c "
from api.middleware.auth import JWTManager, User, create_access_token, verify_token

# Create a test user
user = User(id='test-123', email='test@example.com', name='Test User')

# Create token (should use settings, not hardcoded secret)
token = create_access_token(user)
print(f'Token created: {token[:50]}...')

# Verify token
payload = verify_token(token)
print(f'Verified user: {payload[\"email\"]}')

# Verify no hardcoded secret
import api.middleware.auth as auth_module
source = open(auth_module.__file__).read()
assert 'ceiling-panel-calculator-secret-key-change-in-production' not in source, 'Hardcoded secret still present!'
print('Auth middleware updated - no hardcoded secrets')
"
```
  </verify>
  <done>
    - api/middleware/auth.py imports from core.config
    - Hardcoded JWT_SECRET removed
    - JWTManager uses settings.jwt_secret.get_secret_value()
    - No default fallback secret in code
  </done>
</task>

</tasks>

<verification>
1. Validation catches invalid input:
   ```bash
   python -c "
   from core.validation import CeilingDimensions
   try:
       CeilingDimensions(length_mm=-100, width_mm=1000)
       print('FAIL: Should have raised error')
   except Exception as e:
       print(f'PASS: Caught error: {e}')
   "
   ```

2. Settings load from environment:
   ```bash
   JWT_SECRET=test-secret python -c "
   from core.config import get_settings
   s = get_settings()
   assert s.jwt_secret.get_secret_value() == 'test-secret', 'Env not loaded'
   print('PASS: Settings load from environment')
   "
   ```

3. No hardcoded secrets in auth:
   ```bash
   grep -r "ceiling-panel-calculator-secret-key" api/middleware/auth.py && echo "FAIL: Hardcoded secret found" || echo "PASS: No hardcoded secrets"
   ```
</verification>

<success_criteria>
- [ ] CeilingDimensions validates positive dimensions (100mm-50000mm)
- [ ] PanelSpacing validates non-negative gaps (0-1000mm)
- [ ] ValidationError raised with clear messages for invalid input
- [ ] Settings class loads JWT_SECRET from environment
- [ ] .env.example documents all required variables
- [ ] .gitignore prevents .env from being committed
- [ ] api/middleware/auth.py has no hardcoded secrets
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-repair/01-02-SUMMARY.md`
</output>
