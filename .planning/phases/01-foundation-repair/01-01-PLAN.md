---
phase: 01-foundation-repair
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/ceiling_panel_calc.py
  - core/algorithm_config.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Calculator generates multi-panel layouts (4-16 panels for standard rooms)"
    - "No panel dimension exceeds 2400mm"
    - "Panel aspect ratios stay within practical range (0.5-2.0)"
    - "Algorithm fails gracefully with clear error for impossible layouts"
  artifacts:
    - path: "core/ceiling_panel_calc.py"
      provides: "Fixed CeilingPanelCalculator.calculate_optimal_layout()"
      contains: "max_panel_dimension"
    - path: "core/algorithm_config.py"
      provides: "AlgorithmConfig dataclass with constraints"
      exports: ["AlgorithmConfig"]
  key_links:
    - from: "core/ceiling_panel_calc.py"
      to: "core/algorithm_config.py"
      via: "import AlgorithmConfig"
      pattern: "from.*algorithm_config.*import.*AlgorithmConfig"
---

<objective>
Fix the core panel calculation algorithm to generate practical multi-panel layouts instead of single oversized panels.

Purpose: The current algorithm's efficiency formula rewards larger panels, producing impractical single-panel layouts (e.g., 3200mm x 4400mm). Real construction requires panels <=2400mm that fit through doors and can be installed by standard crews.

Output: Working calculation engine that generates realistic 4-16 panel layouts with configurable constraints.
</objective>

<execution_context>
@/home/tomas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/tomas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-repair/01-RESEARCH.md
@core/ceiling_panel_calc.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AlgorithmConfig dataclass</name>
  <files>core/algorithm_config.py</files>
  <action>
Create a new `core/algorithm_config.py` file with:

```python
from dataclasses import dataclass, field
from typing import Literal, List

@dataclass
class AlgorithmConfig:
    """Configuration for panel layout optimization algorithm."""
    
    # Hard constraints
    max_panel_dimension_mm: float = 2400  # Practical limit for transport/install
    min_panel_dimension_mm: float = 300   # Too small = impractical
    
    # Optimization strategy
    optimization_strategy: Literal['balanced', 'minimize_panels', 'minimize_cuts'] = 'balanced'
    
    # Preferred aspect ratios (width/length)
    preferred_aspect_ratios: List[float] = field(default_factory=lambda: [1.0, 1.5, 2.0])
    
    # Search bounds
    max_panels_per_dimension: int = 50  # Limit search space
    
    def validate(self) -> None:
        """Validate configuration values."""
        if self.max_panel_dimension_mm <= self.min_panel_dimension_mm:
            raise ValueError(
                f"max_panel_dimension ({self.max_panel_dimension_mm}) must be > "
                f"min_panel_dimension ({self.min_panel_dimension_mm})"
            )
        if self.max_panel_dimension_mm > 5000:
            raise ValueError(f"max_panel_dimension ({self.max_panel_dimension_mm}) exceeds 5000mm limit")
        if not self.preferred_aspect_ratios:
            raise ValueError("preferred_aspect_ratios cannot be empty")
```

This dataclass encapsulates all algorithm constraints in one place.
  </action>
  <verify>
    python -c "from core.algorithm_config import AlgorithmConfig; c = AlgorithmConfig(); c.validate(); print('OK')"
  </verify>
  <done>AlgorithmConfig dataclass exists with max_panel_dimension_mm=2400 default and validate() method</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite calculate_optimal_layout with constraints</name>
  <files>core/ceiling_panel_calc.py</files>
  <action>
Modify `CeilingPanelCalculator.calculate_optimal_layout()` method (lines 66-116) to:

1. Accept optional `AlgorithmConfig` parameter
2. Add hard constraint: skip any layout where panel_length > max_panel_dimension OR panel_width > max_panel_dimension
3. Add minimum constraint: skip layouts where any dimension < min_panel_dimension
4. Rewrite efficiency formula to penalize oversized panels instead of rewarding them:

```python
from core.algorithm_config import AlgorithmConfig

def calculate_optimal_layout(
    self, 
    target_aspect_ratio: float = 1.0,
    config: AlgorithmConfig = None
) -> PanelLayout:
    """
    Calculate optimal panel size with practical constraints.
    
    Args:
        target_aspect_ratio: Panel width/length ratio (1.0 = square)
        config: Algorithm configuration with constraints
    
    Returns:
        Optimized PanelLayout with practical panel sizes
    """
    config = config or AlgorithmConfig()
    config.validate()
    
    available_length = self.ceiling.length_mm - (2 * self.spacing.perimeter_gap_mm)
    available_width = self.ceiling.width_mm - (2 * self.spacing.perimeter_gap_mm)
    
    # Pre-check: can we fit at least one panel?
    if available_length < config.min_panel_dimension_mm or available_width < config.min_panel_dimension_mm:
        raise ValueError(
            f"Available space ({available_length:.0f}x{available_width:.0f}mm) too small for minimum "
            f"panel size ({config.min_panel_dimension_mm}mm)"
        )
    
    best_layout = None
    best_score = -1
    
    for panels_length in range(1, config.max_panels_per_dimension + 1):
        for panels_width in range(1, config.max_panels_per_dimension + 1):
            panel_length = (available_length - (panels_length - 1) * self.spacing.panel_gap_mm) / panels_length
            panel_width = (available_width - (panels_width - 1) * self.spacing.panel_gap_mm) / panels_width
            
            # HARD CONSTRAINT: Skip oversized panels
            if panel_length > config.max_panel_dimension_mm or panel_width > config.max_panel_dimension_mm:
                continue
            
            # HARD CONSTRAINT: Skip too-small panels
            if panel_length < config.min_panel_dimension_mm or panel_width < config.min_panel_dimension_mm:
                continue
            
            # Calculate score (higher = better)
            actual_ratio = panel_width / panel_length
            ratio_error = abs(actual_ratio - target_aspect_ratio)
            
            # Coverage (more coverage = better)
            panel_area = panel_length * panel_width
            total_area = available_length * available_width
            coverage_score = (panel_area * panels_length * panels_width) / total_area
            
            # Prefer fewer panels (less labor) but not oversized
            panel_count = panels_length * panels_width
            panel_count_penalty = 1 / (1 + panel_count * 0.02)  # Slight preference for fewer panels
            
            # Aspect ratio closeness
            ratio_score = 1 / (1 + ratio_error)
            
            # Combined score
            score = coverage_score * ratio_score * panel_count_penalty
            
            if score > best_score:
                best_score = score
                best_layout = PanelLayout(
                    panel_width_mm=panel_width,
                    panel_length_mm=panel_length,
                    panels_per_row=panels_width,
                    panels_per_column=panels_length,
                    total_panels=panel_count,
                    total_coverage_sqm=(panel_length * panel_width * panel_count) / 1_000_000,
                    gap_area_sqm=(self.ceiling.length_mm * self.ceiling.width_mm - 
                                  panel_length * panel_width * panel_count) / 1_000_000
                )
                self.layouts.append((best_layout, score))
    
    if best_layout is None:
        raise ValueError(
            f"No valid layout found for ceiling {self.ceiling.length_mm}x{self.ceiling.width_mm}mm "
            f"with constraints (max panel: {config.max_panel_dimension_mm}mm, "
            f"min panel: {config.min_panel_dimension_mm}mm)"
        )
    
    return best_layout
```

Key changes:
- Import AlgorithmConfig at top of file
- Hard constraint enforcement BEFORE efficiency calculation
- New scoring formula that doesn't reward single oversized panels
- Clear error messages for impossible layouts
  </action>
  <verify>
Run test calculation:
```bash
python -c "
from core.ceiling_panel_calc import CeilingDimensions, PanelSpacing, CeilingPanelCalculator

ceiling = CeilingDimensions(length_mm=6000, width_mm=4500)
spacing = PanelSpacing(perimeter_gap_mm=200, panel_gap_mm=200)

calc = CeilingPanelCalculator(ceiling, spacing)
layout = calc.calculate_optimal_layout()

print(f'Panel: {layout.panel_width_mm:.0f}x{layout.panel_length_mm:.0f}mm')
print(f'Grid: {layout.panels_per_row}x{layout.panels_per_column} = {layout.total_panels} panels')

# Verify constraints
assert layout.panel_width_mm <= 2400, f'Panel width {layout.panel_width_mm} exceeds 2400mm'
assert layout.panel_length_mm <= 2400, f'Panel length {layout.panel_length_mm} exceeds 2400mm'
assert layout.total_panels >= 4, f'Only {layout.total_panels} panels - should be at least 4'
print('OK: All constraints satisfied')
"
```
  </verify>
  <done>
    - Panel dimensions never exceed 2400mm
    - 6m x 4.5m ceiling produces 4+ panels (not 1 oversized panel)
    - Algorithm accepts AlgorithmConfig for customization
  </done>
</task>

<task type="auto">
  <name>Task 3: Add algorithm documentation and edge case handling</name>
  <files>core/ceiling_panel_calc.py</files>
  <action>
1. Add inline comments explaining the scoring formula
2. Add edge case handling for:
   - Very small ceilings (< 1m x 1m)
   - Large gaps relative to ceiling size
   - Non-standard aspect ratios

Update the calculate_optimal_layout method with comments:

```python
# SCORING FORMULA EXPLANATION:
# - coverage_score: Higher coverage = less wasted space
# - ratio_score: Closer to target aspect ratio = better aesthetics
# - panel_count_penalty: Slight preference for fewer panels (less labor/seams)
#   but NOT strong enough to prefer single oversized panels
#
# This replaces the old formula which maximized panel_area/(available_area),
# inadvertently rewarding single oversized panels.
```

Also add a helper method for edge case validation:

```python
def _validate_inputs(self, config: AlgorithmConfig) -> None:
    """Validate ceiling dimensions against gap constraints."""
    available_length = self.ceiling.length_mm - (2 * self.spacing.perimeter_gap_mm)
    available_width = self.ceiling.width_mm - (2 * self.spacing.perimeter_gap_mm)
    
    if available_length <= 0:
        raise ValueError(
            f"Perimeter gap ({self.spacing.perimeter_gap_mm}mm x 2) exceeds "
            f"ceiling length ({self.ceiling.length_mm}mm)"
        )
    if available_width <= 0:
        raise ValueError(
            f"Perimeter gap ({self.spacing.perimeter_gap_mm}mm x 2) exceeds "
            f"ceiling width ({self.ceiling.width_mm}mm)"
        )
```

Call this at the start of calculate_optimal_layout().
  </action>
  <verify>
Test edge cases:
```bash
python -c "
from core.ceiling_panel_calc import CeilingDimensions, PanelSpacing, CeilingPanelCalculator

# Edge case 1: Small ceiling
ceiling = CeilingDimensions(length_mm=1000, width_mm=800)
spacing = PanelSpacing(perimeter_gap_mm=50, panel_gap_mm=50)
calc = CeilingPanelCalculator(ceiling, spacing)
layout = calc.calculate_optimal_layout()
print(f'Small ceiling: {layout.panels_per_row}x{layout.panels_per_column} panels')
assert layout.total_panels >= 1

# Edge case 2: Gap too large (should raise error)
try:
    ceiling = CeilingDimensions(length_mm=500, width_mm=500)
    spacing = PanelSpacing(perimeter_gap_mm=300, panel_gap_mm=50)
    calc = CeilingPanelCalculator(ceiling, spacing)
    layout = calc.calculate_optimal_layout()
    print('ERROR: Should have raised ValueError')
except ValueError as e:
    print(f'Correctly caught error: {e}')

print('Edge cases handled correctly')
"
```
  </verify>
  <done>
    - Algorithm has inline documentation explaining scoring formula
    - Edge cases raise clear ValueError with actionable messages
    - _validate_inputs helper method exists
  </done>
</task>

</tasks>

<verification>
1. Run the main calculation test:
   ```bash
   python -c "
   from core.ceiling_panel_calc import CeilingDimensions, PanelSpacing, CeilingPanelCalculator
   
   # Test case from CLAUDE.md: 4.8m x 3.6m ceiling
   ceiling = CeilingDimensions(length_mm=4800, width_mm=3600)
   spacing = PanelSpacing(perimeter_gap_mm=200, panel_gap_mm=200)
   calc = CeilingPanelCalculator(ceiling, spacing)
   layout = calc.calculate_optimal_layout()
   
   print(f'Result: {layout.panel_width_mm:.0f}x{layout.panel_length_mm:.0f}mm')
   print(f'Grid: {layout.panels_per_row}x{layout.panels_per_column} = {layout.total_panels} panels')
   
   # CRIT-01 requirements:
   assert layout.panel_width_mm <= 2400, 'FAIL: Panel width exceeds 2400mm'
   assert layout.panel_length_mm <= 2400, 'FAIL: Panel length exceeds 2400mm'
   assert layout.total_panels >= 4, 'FAIL: Should produce 4+ panels'
   assert layout.total_panels <= 16, 'WARN: More than 16 panels may be excessive'
   print('PASS: CRIT-01 requirements satisfied')
   "
   ```

2. Verify module imports work:
   ```bash
   python -c "from core.algorithm_config import AlgorithmConfig; print('Import OK')"
   ```
</verification>

<success_criteria>
- [ ] AlgorithmConfig dataclass created with max_panel_dimension_mm=2400 default
- [ ] calculate_optimal_layout() enforces max dimension constraint
- [ ] 4.8m x 3.6m ceiling produces 4-16 panels (not 1 panel)
- [ ] Edge cases raise clear ValueError messages
- [ ] Algorithm documentation explains scoring formula
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-repair/01-01-SUMMARY.md`
</output>
