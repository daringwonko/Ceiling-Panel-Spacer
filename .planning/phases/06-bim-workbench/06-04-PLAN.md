---
phase: 06-bim-workbench
plan: 04
type: execute
wave: 1
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - frontend/src/api/bimClient.js
  - frontend/src/hooks/useBIM.js
  - frontend/src/store/useBIMStore.js
  - backend/app.py
autonomous: true
must_haves:
  truths:
    - BIM API client provides CRUD operations for projects, objects, layers, materials
    - React Query hooks handle data fetching and mutations
    - BIM store connects to backend API with loading and error states
    - Backend API endpoints respond to all BIM operations
  artifacts:
    - path: "frontend/src/api/bimClient.js"
      provides: "BIM API client with project, object, layer, material, export endpoints"
      min_lines: 150
    - path: "frontend/src/hooks/useBIM.js"
      provides: "React Query hooks for BIM data management"
      exports: ["useBIMProject", "useBIMObjects", "useCreateObject", "useUpdateObject", "useDeleteObject", "useExportProject"]
    - path: "frontend/src/store/useBIMStore.js"
      provides: "Updated BIM store with API integration"
      contains: "loadProject, saveProject with error handling"
    - path: "backend/app.py"
      provides: "Backend Flask API endpoints for BIM operations"
      contains: ["/api/bim/projects", "/api/bim/objects", "/api/bim/export"]
  key_links:
    - from: "frontend/src/store/useBIMStore.js"
      to: "frontend/src/api/bimClient.js"
      via: "import and method calls"
    - from: "frontend/src/hooks/useBIM.js"
      to: "frontend/src/api/bimClient.js"
      via: "queryFn and mutationFn"
    - from: "frontend/src/api/bimClient.js"
      to: "backend/app.py"
      via: "HTTP requests to /api/bim/*"
---

<objective>
Create the complete API layer for BIM operations with frontend client, React Query hooks, and backend endpoints for project persistence.

Purpose: Enable the BIM Workbench to communicate with the backend for data persistence, enabling collaborative workflows and project management.
Output: Full API layer with typed client, reactive hooks, and RESTful backend endpoints.
</objective>

<execution_context>
@/home/tomas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/tomas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Frontend API client reference
@frontend/src/api/client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BIM API Client</name>
  <files>frontend/src/api/bimClient.js</files>
  <action>
Create a comprehensive BIM API client in `frontend/src/api/bimClient.js` that provides:

Project Endpoints:
- createProject(projectData) → POST /api/bim/projects
- getProject(projectId) → GET /api/bim/projects/:id
- updateProject(projectId, data) → PUT /api/bim/projects/:id
- deleteProject(projectId) → DELETE /api/bim/projects/:id

Object Endpoints:
- createObject(projectId, objectData) → POST /api/bim/objects
- getObject(objectId) → GET /api/bim/objects/:id
- updateObject(objectId, data) → PUT /api/bim/objects/:id
- deleteObject(objectId) → DELETE /api/bim/objects/:id
- getProjectObjects(projectId) → GET /api/bim/projects/:id/objects

Layer Endpoints:
- createLayer(projectId, layerData) → POST /api/bim/layers
- getProjectLayers(projectId) → GET /api/bim/projects/:id/layers
- updateLayer(layerId, data) → PUT /api/bim/layers/:id
- deleteLayer(layerId) → DELETE /api/bim/layers/:id

Material Endpoints:
- getMaterials() → GET /api/bim/materials
- createMaterial(materialData) → POST /api/bim/materials

Export Endpoints:
- exportIFC(projectId) → POST /api/bim/export/ifc
- exportDXF(projectId) → POST /api/bim/export/dxf
- exportSVG(projectId) → POST /api/bim/export/svg
- exportJSON(projectId) → POST /api/bim/export/json

Import Endpoints:
- importIFC(projectId, file) → POST /api/bim/import/ifc
- importDXF(projectId, file) → POST /api/bim/import/dxf

Use the existing client.js as reference for error handling patterns. Include TypeScript-style JSDoc comments. Handle file uploads with FormData for import endpoints. Return promises that resolve to JSON responses.
  </action>
  <verify>
grep -E "(createProject|getProject|createObject|exportIFC|importIFC)" frontend/src/api/bimClient.js
  </verify>
  <done>
All 15+ API methods defined with proper HTTP verbs and URL patterns. File exports a bimClient object with all methods. Error handling follows existing client.js patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React Query Hooks</name>
  <files>frontend/src/hooks/useBIM.js</files>
  <action>
Create React Query hooks in `frontend/src/hooks/useBIM.js` that wrap the BIM API client:

Query Hooks:
- useBIMProject(projectId) - Query for fetching a single project
  - queryKey: ['bim', 'project', projectId]
  - queryFn: bimClient.getProject
  - enabled: Boolean(projectId)
  
- useBIMObjects(projectId) - Query for fetching project objects
  - queryKey: ['bim', 'objects', projectId]
  - queryFn: bimClient.getProjectObjects
  - enabled: Boolean(projectId)

- useBIMLayers(projectId) - Query for fetching project layers
  - queryKey: ['bim', 'layers', projectId]
  - queryFn: bimClient.getProjectLayers

- useMaterials() - Query for fetching available materials
  - queryKey: ['bim', 'materials']
  - queryFn: bimClient.getMaterials

Mutation Hooks:
- useCreateObject() - Mutation for creating objects
  - mutationFn: bimClient.createObject
  - onSuccess: invalidate ['bim', 'objects']

- useUpdateObject() - Mutation for updating objects
  - mutationFn: ({ objectId, data }) => bimClient.updateObject(objectId, data)
  - onSuccess: invalidate object query

- useDeleteObject() - Mutation for deleting objects
  - mutationFn: bimClient.deleteObject
  - onSuccess: invalidate objects list

- useCreateLayer() - Mutation for creating layers
  - mutationFn: bimClient.createLayer

- useUpdateLayer() - Mutation for updating layers
  - mutationFn: ({ layerId, data }) => bimClient.updateLayer(layerId, data)

- useDeleteLayer() - Mutation for deleting layers
  - mutationFn: bimClient.deleteLayer

- useExportProject() - Mutation for project export
  - mutationFn: ({ projectId, format }) => bimClient[`export${format}`](projectId)

- useImportProject() - Mutation for IFC/DXF import
  - mutationFn: ({ projectId, format, file }) => bimClient[`import${format}`](projectId, file)

Include proper TypeScript-style JSDoc. All hooks should handle loading and error states. Export hooks individually and as a grouped object.
  </action>
  <verify>
grep -E "(useBIMProject|useBIMObjects|useCreateObject|useUpdateObject|useDeleteObject|useExportProject)" frontend/src/hooks/useBIM.js | wc -l
grep -E "useQuery|useMutation" frontend/src/hooks/useBIM.js
  </verify>
  <done>
9+ hooks exported, all using React Query. Query keys follow consistent pattern ['bim', entity, id]. Mutations properly invalidate queries on success. All hooks include loading and error states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update BIM Store with API Integration</name>
  <files>frontend/src/store/useBIMStore.js</files>
  <action>
Update the existing useBIMStore in `frontend/src/store/useBIMStore.js` to integrate with the API layer:

Import bimClient and hooks:
- Import bimClient from '../api/bimClient'
- Import React Query hooks from '../hooks/useBIM' (for use in components)

Update store actions:
- loadProject(projectId):
  - Set isLoading: true
  - Call bimClient.getProject(projectId)
  - On success: update store state with project data, set currentProject
  - On error: set error state, log error
  - Always: set isLoading: false

- saveProject(projectData):
  - Set isSaving: true
  - Check if project has id (existing) or not (new)
  - If existing: call bimClient.updateProject(id, projectData)
  - If new: call bimClient.createProject(projectData)
  - On success: update store with returned project, clear isDirty
  - On error: set error state
  - Always: set isSaving: false

- createObject(objectData):
  - Validate objectData has required fields
  - Call bimClient.createObject with currentProject.id and objectData
  - On success: add object to store.objects array
  - On error: set error state

- updateObject(objectId, updates):
  - Find object in store
  - Call bimClient.updateObject(objectId, updates)
  - On success: update object in store.objects
  - On error: set error state

- deleteObject(objectId):
  - Call bimClient.deleteObject(objectId)
  - On success: remove object from store.objects
  - On error: set error state

- exportProject(format):
  - Validate format is one of: 'IFC', 'DXF', 'SVG', 'JSON'
  - Call appropriate bimClient export method
  - Handle file download (create blob, trigger download)
  - Track export history in store

Add new state fields:
- isLoading: boolean - loading state for async operations
- isSaving: boolean - saving state
- error: Error | null - last error
- exportHistory: array - track recent exports

Add error handling utility:
- handleError(error): logs error, sets error state, optionally shows notification

Ensure store remains reactive and components update when state changes. All async operations should properly handle loading states.
  </action>
  <verify>
grep -E "bimClient" frontend/src/store/useBIMStore.js
grep -E "(isLoading|isSaving|error)" frontend/src/store/useBIMStore.js
grep -E "loadProject|saveProject" frontend/src/store/useBIMStore.js
  </verify>
  <done>
Store imports and uses bimClient for all CRUD operations. Loading states (isLoading, isSaving) properly tracked. Error handling implemented for all async operations. Actions update store state on success.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Backend API Stubs</name>
  <files>backend/app.py</files>
  <action>
Create backend API endpoints in `backend/app.py` (or create/update Flask backend) with the following BIM routes:

Project Routes:
```
POST /api/bim/projects
- Create new project
- Request body: { name, description, unit, dimensions?, metadata? }
- Response: { id, name, description, unit, created_at, updated_at }

GET /api/bim/projects/:id
- Get project by ID
- Response: full project with objects, layers, materials

PUT /api/bim/projects/:id
- Update project
- Request body: { name?, description?, unit?, dimensions?, metadata? }
- Response: updated project

DELETE /api/bim/projects/:id
- Delete project and all related data
- Response: { success: true }

GET /api/bim/projects
- List all projects
- Query params: page, limit, search
- Response: { projects: [], total, page, limit }
```

Object Routes:
```
POST /api/bim/objects
- Create new object in project
- Request body: { project_id, type, name, geometry, properties?, layer_id?, material_id? }
- Response: created object with id

GET /api/bim/objects/:id
- Get object by ID
- Response: full object data

PUT /api/bim/objects/:id
- Update object
- Request body: { name?, geometry?, properties?, layer_id?, material_id? }
- Response: updated object

DELETE /api/bim/objects/:id
- Delete object
- Response: { success: true }

GET /api/bim/projects/:id/objects
- Get all objects in project
- Response: { objects: [] }
```

Layer Routes:
```
POST /api/bim/layers
- Create layer
- Request body: { project_id, name, color?, visible?, locked? }

GET /api/bim/projects/:id/layers
- Get project layers

PUT /api/bim/layers/:id
- Update layer

DELETE /api/bim/layers/:id
- Delete layer
```

Material Routes:
```
GET /api/bim/materials
- List available materials

POST /api/bim/materials
- Create custom material
- Request body: { name, color, density?, cost_per_unit? }
```

Export Routes:
```
POST /api/bim/export/ifc
- Export project to IFC
- Request body: { project_id }
- Response: file download or URL

POST /api/bim/export/dxf
- Export project to DXF

POST /api/bim/export/svg
- Export project to SVG blueprint

POST /api/bim/export/json
- Export project to JSON
```

Import Routes:
```
POST /api/bim/import/ifc
- Import IFC file
- Content-Type: multipart/form-data
- Request: { file, project_id? }
- Response: imported project or objects

POST /api/bim/import/dxf
- Import DXF file
```

For now, implement as stubs that return mock data:
- Log request details
- Return appropriate HTTP status codes (200, 201, 404, 500)
- Return JSON with id and timestamps
- Accept all valid requests
- Return 404 for non-existent resources

Add CORS support for frontend. Include basic request logging. Use Flask Blueprint for organization (bim_bp). All routes should follow RESTful conventions.
  </action>
  <verify>
grep -E "@bim_bp.route|@app.route" backend/app.py | wc -l
grep -E "(/api/bim/projects|/api/bim/objects|/api/bim/export)" backend/app.py
grep -E "(POST|GET|PUT|DELETE)" backend/app.py
  </verify>
  <done>
15+ API endpoints defined across projects, objects, layers, materials, export, and import. All return appropriate HTTP status codes. CORS enabled for frontend. Flask Blueprint used for organization.
  </done>
</task>

</tasks>

<verification>
After completion:
1. Verify bimClient.js has all CRUD methods for projects, objects, layers, materials
2. Verify useBIM.js exports all required hooks with proper React Query patterns
3. Verify useBIMStore.js integrates API client and manages loading/error states
4. Verify backend/app.py responds to all defined endpoints
5. Run frontend dev server and test API integration
6. Check console for no import errors or undefined references
7. Verify React Query devtools show queries executing (if enabled)
</verification>

<success_criteria>
- BIM API client provides complete CRUD for all BIM entities
- React Query hooks handle data fetching and mutations with proper caching
- BIM store connects to backend with loading and error states
- Backend API endpoints respond with appropriate status codes
- Frontend can communicate with backend for all BIM operations
- All async operations show loading states
- Errors are properly caught and displayed
</success_criteria>

<output>
After completion, create `.planning/phases/06-bim-workbench/06-04-SUMMARY.md`
</output>
