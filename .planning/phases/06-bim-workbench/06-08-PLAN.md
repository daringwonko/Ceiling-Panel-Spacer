---
phase: 06-bim-workbench
plan: 08
type: execute
wave: 2
depends_on: ["06-07"]
files_modified:
  - src/snap_system.py
  - src/tools/move_tool.py
  - src/tools/rotate_tool.py
  - src/tools/scale_tool.py
  - src/tools/trim_tool.py
  - src/tools/offset_tool.py
  - src/tools/fillet_tool.py
  - src/tools/__init__.py
  - src/workbench/edit_toolbar.py
  - src/workbench/snap_controls.py
  - tests/test_snap_system.py
  - tests/test_edit_tools.py
autonomous: true
user_setup: []
must_haves:
  truths:
    - Snapping works for all snap types (grid, endpoint, midpoint, center, intersection)
    - Snap indicator displays as yellow circle when snap is active
    - Snap distance is configurable
    - Move tool moves selected objects from base point to target
    - Rotate tool rotates objects around center point
    - Scale tool scales objects from base point
    - Trim tool cuts objects at intersection with cutting edge
    - Offset tool creates parallel copy at specified distance
    - Fillet tool creates rounded corner between two lines
  artifacts:
    - path: "src/snap_system.py"
      provides: "Snapping engine with all snap types"
      min_lines: 200
    - path: "src/tools/move_tool.py"
      provides: "Move tool implementation"
      exports: ["MoveTool"]
    - path: "src/tools/rotate_tool.py"
      provides: "Rotate tool implementation"
      exports: ["RotateTool"]
    - path: "src/tools/scale_tool.py"
      provides: "Scale tool implementation"
      exports: ["ScaleTool"]
    - path: "src/tools/trim_tool.py"
      provides: "Trim tool implementation"
      exports: ["TrimTool"]
    - path: "src/tools/offset_tool.py"
      provides: "Offset tool implementation"
      exports: ["OffsetTool"]
    - path: "src/tools/fillet_tool.py"
      provides: "Fillet tool implementation"
      exports: ["FilletTool"]
    - path: "src/workbench/snap_controls.py"
      provides: "UI controls for snap settings"
      exports: ["SnapControls"]
  key_links:
    - from: "src/snap_system.py"
      to: "src/tools/move_tool.py"
      via: "snap_to_point() method"
      pattern: "snap_system.get_snap_point"
    - from: "src/tools/*_tool.py"
      to: "src/core/event_bus.py"
      via: "tool state changes"
      pattern: "event_bus.publish.*tool_"
---

<objective>
Implement snapping system and editing tools for 2D objects.

Purpose: Provide precise editing capabilities for 2D drafting by enabling snapping to key geometric points and providing standard CAD editing tools (move, rotate, scale, trim, offset, fillet). This allows users to create and modify ceiling layouts with professional-grade accuracy and efficiency.

Output: Complete snapping engine and set of editing tools integrated into the workbench UI.
</objective>

<execution_context>
@/home/tomas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/tomas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-bim-workbench/06-07-SUMMARY.md

Prior work established the 2D drafting tools from Plan 07 (Line, Circle, Rectangle, Polyline tools). This plan builds on that foundation to add precision snapping and object editing capabilities.

Key components to integrate with:
- EventBus system for tool state management
- Tool base class from Plan 07
- 2D drafting canvas with object selection
- Tool toolbar system for adding new edit tools
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement snapping system engine</name>
  <files>src/snap_system.py, tests/test_snap_system.py</files>
  <action>Create the core snapping engine that provides precision point detection:

1. Create `SnapSystem` class with the following capabilities:
   - Configurable snap distance (default 10px)
   - Enable/disable individual snap types
   - Priority-based snap selection (closest wins)

2. Implement snap type functions:
   - `snap_grid(point, grid_size)` - snap to nearest grid intersection
   - `snap_endpoint(geometry, point)` - snap to line/polyline end points
   - `snap_midpoint(geometry, point)` - snap to midpoints of lines
   - `snap_center(geometry, point)` - snap to circle/arc centers
   - `snap_intersection(geometry_list, point)` - snap to line intersections

3. Add snap indicator visualization:
   - Yellow circle at snap point
   - Display snap type label ("ENDPOINT", "MIDPOINT", etc.)
   - Fade out when snap lost

4. Create configuration class:
   ```python
   @dataclass
   class SnapConfig:
       enabled: Dict[str, bool]  # grid, endpoint, midpoint, etc.
       snap_distance: int = 10
       grid_size: int = 100
   ```

5. Add tests verifying:
   - Each snap type finds correct point
   - Closest snap wins when multiple in range
   - Snap distance limit respected
   - Disabled snap types not considered

Use geometry utilities from Plan 06 foundation for distance calculations and intersection detection.</action>
  <verify>Run `python -m pytest tests/test_snap_system.py -v` and verify all tests pass including snap detection and indicator rendering</verify>
  <done>SnapSystem class exists with all snap types implemented, configuration working, and tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Create Move tool</name>
  <files>src/tools/move_tool.py, tests/test_edit_tools.py</files>
  <action>Implement the Move tool for translating objects:

1. Create `MoveTool` class inheriting from base Tool:
   ```python
   class MoveTool(Tool):
       def __init__(self, snap_system):
           self.snap_system = snap_system
           self.selected_objects = []
           self.base_point = None
           self.current_point = None
           self.state = MoveState.IDLE
   ```

2. Implement tool states:
   - IDLE: Waiting for object selection
   - SELECTED: Objects selected, waiting for base point
   - MOVING: Base point set, dragging to target

3. Handle mouse events:
   - Click on object(s): Add to selection (with Ctrl for multi-select)
   - Click on empty canvas: Set base point (snapped) or place if moving
   - Drag: Show ghost preview of objects at new position
   - Right-click: Cancel operation

4. Support keyboard input:
   - Type coordinates: "100,200" for relative displacement
   - Enter: Confirm move
   - Escape: Cancel

5. Integrate with snap system:
   - Base point uses snap
   - Target point uses snap
   - Show snap indicator during placement

6. Add test verifying:
   - Object moves correctly to target
   - Snap points used when in range
   - Keyboard input accepted
   - Operation can be cancelled</action>
  <verify>Run `python -m pytest tests/test_edit_tools.py::test_move_tool -v` and verify move functionality works</verify>
  <done>MoveTool class exists, can move objects with mouse or keyboard input, integrates with snapping</done>
</task>

<task type="auto">
  <name>Task 3: Create Rotate and Scale tools</name>
  <files>src/tools/rotate_tool.py, src/tools/scale_tool.py</files>
  <action>Implement Rotate and Scale transformation tools:

1. Create `RotateTool` class:
   - States: IDLE -> SELECTED -> SET_CENTER -> ROTATING
   - Select objects, set rotation center (snapped), rotate by drag or angle input
   - Display rotation arc and angle value during drag
   - Support typing exact angle: "45" for 45 degrees
   - Option for copy mode (rotate copy, keep original)

2. Create `ScaleTool` class:
   - States: IDLE -> SELECTED -> SET_BASE -> SCALING
   - Select objects, set base point (snapped), scale by drag or factor input
   - Display scale factor during drag
   - Support uniform and non-uniform scaling
   - Support typing scale factor: "0.5" for half size
   - Option for copy mode

3. Both tools should:
   - Use snap system for center/base point selection
   - Show ghost preview during operation
   - Support keyboard input for exact values
   - Support Enter to confirm, Escape to cancel
   - Integrate with event bus for state updates

4. Add to `src/tools/__init__.py` exports:
   ```python
   from .move_tool import MoveTool
   from .rotate_tool import RotateTool
   from .scale_tool import ScaleTool
   ```

5. Add toolbar integration placeholders (full UI in later task)</action>
  <verify>Import test: `python -c "from src.tools import MoveTool, RotateTool, ScaleTool; print('OK')"` succeeds</verify>
  <done>RotateTool and ScaleTool classes exist with full transformation capabilities</done>
</task>

<task type="auto">
  <name>Task 4: Create Trim, Offset, and Fillet tools</name>
  <files>src/tools/trim_tool.py, src/tools/offset_tool.py, src/tools/fillet_tool.py</files>
  <action>Implement advanced editing tools for 2D geometry:

1. Create `TrimTool` class:
   - Select cutting edges first (lines that will cut)
   - Then click objects to trim at intersection with cutting edges
   - Support trim and extend modes
   - Visual feedback: highlight cutting edges, show trim preview
   - Handle multiple intersections (trim closest to click)

2. Create `OffsetTool` class:
   - Select object to offset (line, polyline, circle)
   - Click to specify side (left/right of line, inside/outside of shape)
   - Type distance or drag to specify offset amount
   - Create parallel copy at specified distance
   - Option to delete original

3. Create `FilletTool` class:
   - Select two lines that form a corner
   - Type radius for the fillet (rounded corner)
   - Create arc tangent to both lines
   - Trim original lines to meet the arc
   - Support zero radius (sharp corner trim)

4. Implementation requirements:
   - All tools use snap system for point selection
   - All show preview before committing
   - All support Enter to confirm, Escape to cancel
   - Proper error handling (e.g., lines don't intersect for fillet)

5. Update `src/tools/__init__.py` with new exports

6. Add geometry helper functions as needed:
   - `line_intersection(line1, line2)` -> point or None
   - `point_line_distance(point, line)` -> float
   - `offset_line(line, distance, side)` -> Line
   - `create_fillet_arc(line1, line2, radius)` -> Arc</action>
  <verify>Import test: `python -c "from src.tools import TrimTool, OffsetTool, FilletTool; print('OK')"` succeeds</verify>
  <done>TrimTool, OffsetTool, and FilletTool classes exist with full editing capabilities</done>
</task>

<task type="auto">
  <name>Task 5: Create snap controls UI</name>
  <files>src/workbench/snap_controls.py, src/workbench/edit_toolbar.py</files>
  <action>Create UI components for snapping and editing tools:

1. Create `SnapControls` widget:
   - Panel with toggle buttons for each snap type:
     * Grid snap (checkbox + grid size input)
     * Endpoint snap (checkbox)
     * Midpoint snap (checkbox)
     * Center snap (checkbox)
     * Intersection snap (checkbox)
   - Snap distance slider/input (1-50 pixels)
   - Visual indicator showing active snaps
   - Save/load snap preferences

2. Create `EditToolbar` class:
   - Toolbar with buttons for each edit tool:
     * Move (four-way arrows icon)
     * Rotate (circular arrow icon)
     * Scale (expand arrows icon)
     * Trim (scissors icon)
     * Offset (parallel lines icon)
     * Fillet (rounded corner icon)
   - Tool buttons show pressed state when active
   - Tooltip showing tool name and shortcut key
   - Disable tools when no objects selected (where applicable)

3. Integrate with workbench:
   - Connect toolbar buttons to tool activation
   - Connect snap controls to SnapSystem configuration
   - Update UI when snap settings change
   - Update UI when tool state changes

4. Add keyboard shortcuts:
   - M: Move
   - RO: Rotate
   - SC: Scale
   - TR: Trim
   - O: Offset
   - F: Fillet
   - F3: Toggle grid snap
   - F8: Toggle ortho mode (90-degree constraint)
   - F9: Toggle all snaps

5. Style with workbench theme (dark mode compatible)</action>
  <verify>Run workbench and verify toolbar buttons appear and snap controls are functional</verify>
  <done>SnapControls and EditToolbar widgets exist and integrated with tools</done>
</task>

<task type="auto">
  <name>Task 6: Integration and testing</name>
  <files>tests/test_edit_tools.py</files>
  <action>Complete integration and comprehensive testing:

1. Create integration tests:
   ```python
   def test_snap_and_move_integration():
       # Test that snapping works during move operation
       pass
   
   def test_full_edit_workflow():
       # Test complete workflow: draw -> select -> move -> rotate -> trim
       pass
   
   def test_tool_state_transitions():
       # Verify all tools handle state transitions correctly
       pass
   ```

2. Test snapping accuracy:
   - Endpoint snap finds exact line ends
   - Midpoint snap finds exact center of line
   - Intersection snap finds crossing points
   - Grid snap aligns to grid correctly
   - Closest snap wins within snap distance

3. Test tool operations:
   - Move: Objects end at correct position
   - Rotate: Objects rotated correct angle
   - Scale: Objects scaled correct amount
   - Trim: Objects trimmed at correct point
   - Offset: Parallel lines at correct distance
   - Fillet: Rounded corner with correct radius

4. Test error handling:
   - Fillet with parallel lines (no intersection)
   - Offset with invalid distance
   - Trim with no cutting edge intersection
   - All tools handle empty selection gracefully

5. Performance check:
   - Snap detection < 16ms for 100 objects
   - Tool preview rendering smooth at 60fps
   - No memory leaks during repeated operations

6. Run full test suite:
   ```bash
   python -m pytest tests/test_snap_system.py tests/test_edit_tools.py -v --tb=short
   ```</action>
  <verify>Run full test suite and verify all tests pass with >80% coverage</verify>
  <done>All integration tests pass, tools work together correctly, performance targets met</done>
</task>

</tasks>

<verification>
## Wave 2 Verification

After completing this plan:

1. **Snap System:**
   - [ ] All 5 snap types (grid, endpoint, midpoint, center, intersection) work
   - [ ] Snap indicator shows as yellow circle when snapping
   - [ ] Snap distance configurable via UI
   - [ ] Individual snap types can be enabled/disabled

2. **Editing Tools:**
   - [ ] Move tool translates objects correctly
   - [ ] Rotate tool rotates around specified center
   - [ ] Scale tool scales from base point
   - [ ] Trim tool cuts objects at cutting edges
   - [ ] Offset tool creates parallel copies
   - [ ] Fillet tool creates rounded corners

3. **UI Integration:**
   - [ ] Edit toolbar with all tool buttons
   - [ ] Snap controls panel with toggles
   - [ ] Keyboard shortcuts work (M, RO, SC, TR, O, F)
   - [ ] Tooltips display correctly
   - [ ] Active tool highlighted

4. **Quality Checks:**
   - [ ] All unit tests pass
   - [ ] Integration tests pass
   - [ ] Code coverage >80%
   - [ ] No linting errors
</verification>

<success_criteria>
## Measurable Completion

This plan is complete when:

1. **Snapping:** Users can snap to grid, endpoints, midpoints, centers, and intersections with visual feedback
2. **Editing Tools:** All 6 tools (Move, Rotate, Scale, Trim, Offset, Fillet) work with mouse and keyboard input
3. **UI:** Toolbar and snap controls integrated into workbench
4. **Tests:** All tests pass with >80% coverage
5. **Performance:** Snap detection < 16ms, smooth tool previews

**Wave 2 Completion:** 2D drafting tools + snapping and editing = professional-grade 2D CAD capabilities
</success_criteria>

<output>
After completion, create `.planning/phases/06-bim-workbench/06-08-SUMMARY.md` documenting:
- Snap system architecture and snap types implemented
- Editing tools created and their capabilities
- UI components added
- Test coverage achieved
- Integration notes for 3D tools in Wave 3
</output>
