---
phase: 02-architecture-3d
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/exceptions.py, src/logging_utils.py, src/system_orchestrator.py, main modules for print replacement]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Custom exceptions are raised and caught for specific error types"
    - "Structured logging provides consistent log output across modules"
    - "SystemOrchestrator registers and executes workflow steps"
  artifacts:
    - path: "src/exceptions.py"
      provides: "Custom exception hierarchy"
      contains: "class BuildScaleError"
    - path: "src/logging_utils.py"
      provides: "Logging utilities"
      exports: ["get_logger", "setup_logging"]
    - path: "src/system_orchestrator.py"
      provides: "Workflow execution framework"
      contains: "class SystemOrchestrator"
  key_links:
    - from: "src/exceptions.py"
      to: "module imports"
      via: "import BuildScaleError"
      pattern: "from exceptions import"
    - from: "src/logging_utils.py"
      to: "logger usage"
      via: "get_logger(__name__)"
      pattern: "get_logger"
    - from: "src/system_orchestrator.py"
      to: "workflow execution"
      via: "register_step, execute_workflow"
      pattern: "orchestrator.register_step"
---

<objective>
Implement foundation for Phase 2: Unified error handling, logging, and SystemOrchestrator

Purpose: Establish core infrastructure for scalable error management, consistent logging, and workflow orchestration to support 3D architecture features. This foundation enables robust error recovery, debugging, and modular system composition.

Output: New exception hierarchy, logging utilities, orchestrator class, and updated print statements to logger calls.
</objective>

<execution_context>
@/home/tomas/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/tomas/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context for integration
@.planning/phases/01-foundation/summarys/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create Unified Exception Hierarchy</name>
  <files>src/exceptions.py</files>
  <action>Create a new exceptions.py module with a hierarchy of custom exceptions:
- Base BuildScaleError
- ValidationError for input validation
- CalculationError for computation issues
- SystemError for infrastructure problems
Include proper docstrings and inheritance. Use @dataclass if needed for additional attributes.</action>
  <verify>import exceptions; assert issubclass(exceptions.ValidationError, exceptions.BuildScaleError)</verify>
  <done>Custom exception classes are defined and can be imported</done>
</task>

<task type="auto">
  <name>Implement Structured Logging System</name>
  <files>src/logging_utils.py</files>
  <action>Create logging_utils.py with:
- get_logger(name) function returning configured logger
- setup_logging(level, format) function for configuration
- Use standard logging module with JSON or structured format
- Default to INFO level with timestamp and module name in format</action>
  <verify>from logging_utils import get_logger; logger = get_logger('test'); assert logger.name == 'test'</verify>
  <done>Logging utilities are operational and configure loggers consistently</done>
</task>

<task type="auto">
  <name>Create Fractional SystemOrchestrator</name>
  <files>src/system_orchestrator.py</files>
  <action>Create system_orchestrator.py with:
- SystemOrchestrator class
- register_step(name, function) method for adding workflow steps
- execute_workflow(steps) method to run sequence of registered steps
- Include error handling with custom exceptions</action>
  <verify>// Test registration and execution (pseudo-test)
orchestrator = SystemOrchestrator()
orchestrator.register_step('init', lambda: True)
result = orchestrator.execute_workflow(['init'])
assert result is not None</verify>
  <done>Orchestrator can register steps and execute workflows</done>
</task>

<task type="auto">
  <name>Replace Print Statements with Logger Calls</name>
  <files>// Identify and update main modules with print statements</files>
  <action>Search existing codebase for print statements using grep, then replace with logger calls:
- Import get_logger from logging_utils
- Replace print() with logger.info() or appropriate level
- Ensure logger is configured in main entry points</action>
  <verify>grep -r "print(" src/ | wc -l returns 0 (or significantly reduced)</verify>
  <done>No print statements remain; logging is used throughout</done>
</task>

</tasks>

<verification>
Run pytest on new modules and updated files
Check that custom exceptions are raised correctly
Verify log output is structured
Test orchestrator workflow execution
</verification>

<success_criteria>
Custom exceptions can be caught specifically
Logs show consistent structured output
Orchestrator runs registered workflows successfully
Print statements are replaced with logger calls
All code passes linter with error handling best practices
</success_criteria>

<output>
After completion, create .planning/phases/02-architecture-3d/02-01-SUMMARY.md
</output>